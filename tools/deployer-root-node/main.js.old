/* eslint no-console: ["error", { allow: ["warn", "error", "log"] }] */

const ArgvHelper = require('./argv-helper');
const Config = require('./../../config/config');
const SecretsConfig = require('./secrets.json');

const SCP2 = require('scp2');
const SSH2Client = require('ssh2').Client;
const path = require('path');
const fs = require('fs');
const archiver = require('archiver');
const util = require('util');

const mkdir = util.promisify(fs.mkdir);
const stat = util.promisify(fs.stat);
const unlink = util.promisify(fs.unlink);
const packageJSON = require('../../package.json');

const Secrets = SecretsConfig[ArgvHelper.TARGET];
if (Secrets === undefined) {
    console.error(`Secrets with target not found. Target:${ArgvHelper.TARGET}`);
    return;
}

console.log(`Target: ${ArgvHelper.TARGET}`);
console.log(`Server Dir: ${Secrets.serverPath}`);

const date = new Date();
const version = packageJSON.version;
const deployFilename = `ver_${version.split('.').join('_')}.zip`;
console.log(deployFilename);

class Deployer {
    createArchive() {
        return new Promise(async (resolve, reject) => {
            try {
                const statsDir = await stat(Config.Path.Builds.Temp.DEPLOYS);
            } catch (e) {
                if (e.code === 'ENOENT') {
                    await mkdir(Config.Path.Builds.Temp.DEPLOYS);
                } else {
                    reject(e);
                }
            }

            const filePath = path.join(Config.Path.Builds.Temp.DEPLOYS, deployFilename);
            try {
                const statsFile = await stat(filePath);
                if (statsFile.isFile()) {
                    await unlink(filePath);
                }
            } catch (e) { }

            const output = fs.createWriteStream(filePath);
            const archive = archiver('zip', {
                zlib: { level: 9 }, // Sets the compression level.
            });

            output.on('close', () => {
                console.log(`${archive.pointer()} total bytes`);
                console.log('archiver has been finalized and the output file descriptor has closed.');
                resolve({
                    path: filePath,
                    name: deployFilename,
                });
            });

            output.on('end', () => {
                console.log('Data has been drained');
            });

            archive.on('warning', (err) => {
                if (err.code === 'ENOENT') {
                    // log warning
                } else {
                    // throw error
                    reject(err);
                }
            });

            // good practice to catch this error explicitly
            archive.on('error', (err) => {
                reject(err);
            });

            // pipe archive data to the file
            archive.pipe(output);

            // append files from a sub-directory, putting its contents at the root of archive
            archive.directory(Config.Path.PROD, false);

            archive.finalize();
        });
    }

    uploadFile(fileInfo) {
        return new Promise(((resolve, reject) => {
            const spcClient = new SCP2.Client();
            spcClient.on('connect', () => {
                console.log('Connected to server.');
            });

            spcClient.on('transfer', (buffer, uploaded, total) => {
                console.log(`Uploaded: ${uploaded}/${total}`);
            });

            const destOptions = {
                host: Secrets.host,
                port: Secrets.port,
                username: Secrets.username,
                passphrase: Secrets.keyPass,
                privateKey: require('fs').readFileSync(Secrets.privateKey),
                path: Secrets.serverPath,
            };

            SCP2.scp(fileInfo.path, destOptions, spcClient, (err) => {
                if (err) {
                    console.error('Error:', err);
                    reject(err);
                    return;
                }

                resolve();
            });
        }));
    }

    executeCommands(fileInfo) {
        const conn = new SSH2Client();
        const filePath = `${Secrets.serverPath}/${fileInfo.name}`;

        const newVersionName = fileInfo.name.replace('.zip', '');
        const newVersionPath = `${Secrets.serverPath}/${newVersionName}`;
        const commands = [
            'pwd',
            `cd ${Secrets.serverPath}`,
            `unzip -o ${filePath} -d ${newVersionName}`, // Unzip new version
            `rm ${filePath}`, // Remove zip
            `mv ${Secrets.maintancePath}/maintenance-inactive.html ${Secrets.maintancePath}/maintenance.html`, // Put site in maintance mode
            `php ${newVersionPath}/src/backend/DB/Cli/ExecuteMigrations.php`, // Migrate DB Platform
            `rm ${Secrets.activeLinkPath}`,
            `ln -s ${newVersionPath} ${Secrets.activeLinkPath}`,
            `mv ${Secrets.maintancePath}/maintenance.html ${Secrets.maintancePath}/maintenance-inactive.html`, // Remove maintance mode
        ];

        let command = '';
        for (const commandLine of commands) {
            command += `${commandLine} && `;
        }
        command += ' echo "DONE"';
        console.log('Command: ', command);

        conn.on('ready', () => {
            console.log('Client :: ready');
            conn.exec(command, (err, stream) => {
                if (err) throw err;
                stream
                    .on('close', (code, signal) => {
                        console.log(`Stream :: close :: code: ${code}, signal: ${signal}`);
                        conn.end();
                    })
                    .on('data', (data) => {
                        console.log(`STDOUT: ${data}`);
                    })
                    .stderr.on('data', (data) => {
                        console.log(`STDERR: ${data}`);
                    });
            });
        });

        conn.connect({
            host: Secrets.host,
            port: Secrets.port,
            username: Secrets.username,
            passphrase: Secrets.keyPass,
            privateKey: require('fs').readFileSync(Secrets.privateKey),
            path: Secrets.serverPath,
        });
    }

    async deploy() {
        try {
            const fileInfo = await this.createArchive();

            console.log('Start of uploading files.');

            await this.uploadFile(fileInfo);

            console.log('Finish uploading files.');
            console.log('Restart nodejs process.');

            this.executeCommands(fileInfo);

            console.log('Process restarted successful.');
        } catch (e) {
            console.error(e);
        }
    }
}

const deployer = new Deployer();
deployer.deploy();
